#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    // Объявление переменных
    int *m = NULL, *h = NULL;  // m - основной массив, h - массив для максимумов
    int i, j, n;               // Индексы и количество столбцов
    int k = 1, c = 0;          // k - коэффициент расширения, c - счетчик строк
    int l, tmp, v, max;        // Вспомогательные переменные
    char s[512], *str;         // Буфер для чтения строк и указатель для парсинга
    FILE *f;                   // Файловый указатель

    // Открытие файла для чтения
    f = fopen("data.txt", "r");
    if (f == NULL) {
        printf("Can't open file");
        return -1;
    }

    // Чтение количества столбцов из первой строки файла
    if (fscanf(f, "%d\n", &n) != 1) {
        printf("Empty file");
        return -2;
    }

    // Выделение начальной памяти для массива m
    m = (int*)malloc(sizeof(int) * n);

    // Чтение данных из файла построчно
    while (fgets(s, sizeof(s), f) != NULL) {
        str = s;  // Указатель на начало строки для парсинга

        // Проверка необходимости расширения массива
        if (k == c) {
            k *= 2;  // Удваиваем коэффициент расширения
            m = (int*)realloc(m, sizeof(int) * n * k);  // Перевыделяем память
        }

        // Парсинг n чисел из текущей строки
        for (i = 0; i < n; i++) {
            // Чтение числа и количества обработанных символов
            if (sscanf(str, "%d%n", &m[i + c * n], &l) != 1) {
                printf("ERROR");
                free(m);
                return -3;
            }
            str += l;  // Сдвигаем указатель на следующее число
        }

        c++;  // Увеличиваем счетчик строк

        // Проверка на наличие лишних чисел в строке
        if (sscanf(str, "%d%n", &m[i + c * n], &l) == 1) {
            printf("ERROR\n");
            free(m);
            return -4;
        }
    }

    // Сортировка строк массива m по убыванию первого элемента строки
    for (i = 0; i < c; i++) {
        for (j = 0; j < c - 1; j++) {
            // Сравниваем первые элементы соседних строк
            if (m[j * n] < m[(j + 1) * n]) {
                // Обмен всей строки местами
                for (v = 0; v < n; v++) {
                    tmp = m[j * n + v];
                    m[j * n + v] = m[(j + 1) * n + v];
                    m[(j + 1) * n + v] = tmp;
                }
            }
        }
    }

    // Вывод отсортированного массива
    for (i = 0; i < c; i++) {
        for (j = 0; j < n; j++) {
            printf("%d ", m[i * n + j]);
        }
        printf("\n");
    }

    // Создание массива h для хранения максимальных элементов каждой строки
    h = (int*)malloc(sizeof(int) * c);
    for (i = 0; i < c; i++) {
        max = m[i * n];  // Предполагаем, что первый элемент строки - максимальный
        // Поиск максимального элемента в строке
        for (j = 0; j < n; j++) {
            if (m[i * n + j] > max) {
                max = m[i * n + j];
            }
        }
        h[i] = max;  // Сохраняем максимум для текущей строки
    }

    // Вывод массива с максимальными элементами
    for (i = 0; i < c; i++) {
        printf("%d ", h[i]);
    }

    // Освобождение памяти и закрытие файла
    free(h);
    free(m);
    fclose(f);

    return 0;
}